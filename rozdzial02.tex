\chapter{Budowa aplikacji}
Podczas realizacji pracy powstaæ ma autorska aplikacja, której bezpieczeñstwo ma byæ weryfikowane odpowiednimi testami. W niniejszym rozdziale opisano wymagania dla tej aplikacji, jak równie¿ sposób jej implementacji. 

\section{Analiza wymagañ}
Projektowana aplikacja ma byæ aplikacj¹ internetow¹, umo¿liwiaj¹c¹ wystawianie og³oszeñ o~produktach, które jej u¿ytkownicy chcieliby oddaæ lub sprzedaæ, jak równie¿ pozwalaj¹c¹ na przegl¹dnie wystawionych og³oszeñ. Zgodnie z powszechnie stosowanymi praktykami, dostêp do oferowanych przez t¹ aplikacjê funkcji powinien byæ ograniczany zgodnie posiadanymi przez u¿ytkowników uprawnieniami. Dlatego w aplikacji powinien dzia³aæ mechanizm rejestrowania u¿ytkowników oraz zarz¹dzania ich kontami. Zarejestrowani u¿ytkownicy, po zalogowaniu, powinni móc: wyœwietlaæ informacje o w³aœcicielu konta, zarz¹dzaæ w³asnymi og³oszeniami, wyœwietlaæ listy wszystkich wystawionych og³oszeñ. 
% TO DO: Dokoñczyæ ogólny opis miejsca wdro¿enia (system operacyjny, infrastruktura) OK

Sama aplikacja wdro¿ona powinna byæ w systemie operacyjnym Windows 10. G³ównym komponentem infrastruktury jest serwer aplikacji webowej, w którego sk³ad nale¿y Python z~frameworkiem Flask i bibliotekami. Do pozsota³ych zalicza siê klient z przegl¹dark¹ internetow¹ oraz us³uga baz danych MySQL. Serwer utrzymuje po³¹czenie z klientem odpowiadaj¹c na ¿¹dania wys³ane przez niego, przetwarza dane oraz komunikuje siê z us³ug¹, dziêki bibliotece \texttt{flask\_mysqldb} (rys.~\ref{fig:Rys02/Architektura}).  


% TO DO: przyda³by siê diagram z architektur¹, podobny do: https://www.mindinventory.com/blog/wp-content/uploads/2021/01/web-application-architecture-diagram.png
% ze strony: https://www.mindinventory.com/blog/web-application-architecture/
% lub, po odpowiedniej modyfikacji, diagram podobny do: https://miro.medium.com/max/700/1*kTu98E30yJeFslxYunOJpA.png
% ze strony https://cmmorrow.medium.com/using-sqlalchemy-and-flask-to-build-a-simple-data-driven-web-app-17e2d43778bb OK
%\newpage
\begin{figure}[htb]
\centering
\includegraphics[scale=0.6]{Rys02/Architektura}
\caption{Diagram architektury aplikacji}
\label{fig:Rys02/Architektura}
\end{figure}

Zwykle wymagania aplikacji opisuje siê minimalnie w podziale na: wymagania funkcjonalne i niefunkcjonalne. Pierwsze z nich okreœlaj¹ mo¿liwoœci zapewniane u¿ytkownikowi, je¿eli aplikacja prawid³owo dzia³a. Drugie przedstawiaj¹ mo¿liwoœci wynikaj¹ce oraz na³o¿one ograniczenia w celu zwiêkszenia wydajnoœci aplikacji. Mog¹ definiowaæ funkcje zwi¹zane z~bezpieczeñstwem, wydajnoœci¹ lub wygod¹ korzystania z aplikacji. Podzia³ na takie wymagania zastosowano równie¿ w niniejszej pracy. Wymagania te opisano skrótowo w poni¿szych podrozdzia³ach.
\subsection{Wymagania funkcjonalne}
dostêp do wszystkich wymienionych ni¿ej funkcji, prócz logowanie siê i tworzenie konta, ma byæ mo¿liwy tylko dla zalogowanego u¿ytkownika.
\begin{itemize}[leftmargin=1cm]
	\item Tworzenie nowego konta
	\item Logowanie siê na konto
	\item Dodanie nowego og³oszenia
	\item Wyœwietlenie wszystkich og³oszeñ
	\item Wyœwietlenie og³oszeñ stworzonych przez u¿ytkownika
	\item Usuwanie og³oszenia stworzonych przez u¿ytkownika
	\item Wyœwietlanie personalnych informacji
	\item Wylogowanie siê z konta
\end{itemize}
  

\subsection{Wymagania niefunkcjonalne}

\begin{itemize}[leftmargin=1cm]
  \item Wydajnoœæ: aplikacja powinna obs³u¿yæ dwustu u¿ytkowników (w tym trzydziestu pracuj¹cych równoczeœnie). Czas reakcji powinien byæ akceptowalny, choæ nie jest specjalnie istotny. 
	\item Kompatybilnoœæ: aplikacja ma byæ niezale¿nym systemem, korzystaj¹cym z w³asnej bazy danych (nie przewiduje siê koniecznoœci korzystania z innych systemów b¹dŸ us³ug zewnêtrznych)
	\item Œrodowisko: aplikacja powinna poprawnie dzia³aæ w popularnych przegl¹darkach internetowych, jak Chrome, Opera lub Firefox (Maksymalnie jeden u¿ytkownika zalogowany w aplikacji na danych urz¹dzeniu, informacje o jego sesji powinny byæ przechowywane); miejscem wdro¿enia aplikacji powinien byæ serwer dzia³aj¹cym pod kontrol¹ systemu operacyjnego Windows 10
  \item Przenoszalnoœæ: nie przewiduje siê koniecznoœci zapewnienia ³atwoœci zmiany ustawieñ lokalizacyjnych aplikacji, zmiany œrodowiska ani importu/eksportu danych
\end{itemize}

\section{Projekt bazy danych}
Podczas projektowania schematu bazy danych stworzono kolejno trzy modele: uproszczony model konceptualny, rozszerzony model konceptualny (inaczej model logiczny) oraz model fizyczny. Opieraj¹c siê na nich stworzono i wygenerowano bazê danych u¿yt¹ podczas implementacji aplikacji.

Modelowanie schematów baz danych mo¿e odbywaæ siê z wykorzystaniem ró¿nych notacji. W niniejszej pracy pos³u¿ono siê elementami notacji ,,kurzej ³apki'' (ang.~\emph{Crow's Foot Notation}). Elementy tej notacji pojawiaj¹ siê w ró¿nych standardach modelowania, np. w Notacji In¿ynierii Informacyjnej/Relacyjnej (ang.~\emph{Information Engineering/Relational Notation}, IE/Relational Notation) czy te¿ w Notacji Bakera (ang.~\emph{Barker's Notation}). Wymienione notacje opisano, a~nastêpnie porównano w jednym z rodzia³ów atryku³u \cite{AK18}.


\subsection{Uproszczony model konceptualny}
Pierwszy z przedstawionych modeli pokazuje encje oraz wystêpuj¹ce pomiêdzy nimi relacje (rys.~\ref{fig:Rys03/UproszczonyModelKonceptualny}). Schemat bazy danych opiera siê na tabeli \texttt{U¿ytkownik}. Jako jedyna posiada ona relacje z pozosta³ymi encjami. Miêdzy tabel¹ \texttt{U¿ytkownik} oraz \texttt{Personalia} istnieje relacja identyfikuj¹ca. Mówi ona o tym, ¿e tabela \texttt{Personalia} dziedziczy klucz g³ówny od tabeli U¿ytkownik. W przypadku relacji pomiêdzy encj¹ \texttt{U¿ytkownik} i \texttt{Oferta} istnieje relacja nieidentyfikuj¹ca, poniewa¿ obie tabele posiadaj¹ dwa ró¿ne klucze g³ówne.
\begin{figure}[htb]
\centering
\includegraphics[scale=1.4]{Rys03/UproszczonyModelKonceptualny}
\caption{Uproszczony model konceptualny}
\label{fig:Rys03/UproszczonyModelKonceptualny}
\end{figure}

\subsection{Rozszerzony model konceptualny}
Korzystaj¹c z uproszczonego modelu konceptualnego stworzono jego rozszerzon¹ wersjê jak na rysunku~\ref{fig:Rys03/ModelLogiczny}. Tabele w tym modelu posiadaj¹ dwie kolumny: w lewej wpisywane s¹ oznaczenia kluczy (jeœli dany atrybut jest kluczem), w prawej zaœ nazwy atrybutów. Ka¿da encja posiada klucz g³ówny (ang.~\emph{primary key}, PK). Encje \texttt{U¿ytkownik} i \texttt{Oferta} posiadaj¹ kolejno klucze g³ówne o nazwie \texttt{ID\_u¿ytkownika} oraz \texttt{ID\_oferty}. Encja \texttt{Pesonalia} dziedziczy klucz g³ówny od encji \texttt{U¿ytkownik}, który jest zarazem kluczem obcym (ang.~\emph{foreign key}, FK). Ponadto encja \texttt{Oferta} dziedziczy g³ówny klucz encji \texttt{U¿ytkownik} jako klucz obcy. Pod kluczami wypisano wszystkie indeksy jakie nale¿¹ do poszczególnych encji.
\begin{figure}[ht]
\centering
\includegraphics[scale=1.4]{Rys03/ModelLogiczny}
\caption{Rozszerzony model konceptualny}
\label{fig:Rys03/ModelLogiczny}
\end{figure}

%\newpage
%\vfill
\subsection{Model fizyczny}
Opieraj¹c siê na rozszerzonym modelu konceptualnym sporz¹dzono model fizyczny jak na rysunku~\ref{fig:Rys03/ModelFizyczny}). Podczas nazywania elementów tego modelu zrezygnowano z u¿ywania polskich znaków diakrytycznych. Encje maj¹ po dwie kolumny: lewa zawiera nazwy indeksów, oznaczenia kluczy g³ównych i obcych, natomiast w prawej kolumnie okreœlono cechy poszczególnych indeksów. Znaczenia u¿ytych skrótów wyjaœniono poni¿ej.
\begin{itemize}[leftmargin=1cm]
\item ograniczenia:
\begin{itemize}
	\item \texttt{NOT NULL} -- indeks nigdy nie mo¿e przyj¹æ, przechowywaæ wartoœci \texttt{NULL},
	\item \texttt{UNIQUE} -- indeks musi posiadaæ inn¹ wartoœæ dla ka¿dego wpisu w encji,
\end{itemize}
\item typy danych:
	\begin{itemize}
		\item \texttt{int} -- wartoœæ mo¿e byæ liczb¹ ca³kowit¹ z przedzia³u <$2^{-31}-1$;    $2^{31}-1$> 
		\item \texttt{double} -- wartoœæ mo¿e byæ liczb¹ dziesiêtn¹
		\item \texttt{varchar[x]} -- wartoœæ mo¿e byæ ci¹giem znaków o maksymalnej d³ugoœci \texttt{x}. W przypadku napisania krótszego ci¹gu znaków nie wype³nia brakuj¹cych znaków spacjami,
		\item \texttt{text} -- wartoœæ mo¿e byæ d³ugim ci¹giem znaków, zawieraj¹cym do $2^{31}-1$ znaków.
	\end{itemize} 
\end{itemize}

\begin{figure}[htb]
\centering
\includegraphics[scale=1.4]{Rys03/ModelFizyczny}
\caption{Model fizyczny}
\label{fig:Rys03/ModelFizyczny}
\end{figure}

%\newpage
\subsection{Generowanie bazy danych}
Stosuj¹c ostatni z przedstawionych modeli, czyli model fizyczny, i narzêdzie MySQL Workbench wygenerowano bazê danych. Najpierw skorzystano z edytora diagramu EER (ang.~\emph{Enhanced entity-relationship}), aby stworzyæ za jego pomoc¹ odpowiednik przedstawionego modelu fizycznego (rys.~\ref{fig:Rys03/EERDiagram.png}). W kolejnym kroku wybrano opcjê generowania bazy na podstawie stworzonego diagramu. Proces ten zakoñczy³ siê sukcesem (rys.~\ref{fig:Rys03/Success.png}).
\begin{figure}[htb]
\centering
\includegraphics[scale=0.8]{Rys03/EERDiagram.png}
\caption{Diagram EER utworzony w MySQL Workbench}
\label{fig:Rys03/EERDiagram.png}
\end{figure}

\newpage
\begin{figure}[htb]
\centering
\includegraphics[scale=0.38]{Rys03/Success.png}
\caption{Pozytywnie zakoñczone tworzenie bazy w MySQL Workbench}
\label{fig:Rys03/Success.png}
\end{figure}

\section{Implementacja aplikacji}
\subsection{Podstawa programu}
Ka¿dorazowo przy uruchamianiu aplikacji wykonywany jest poni¿szy kod (lis.~\ref{lst:Podstawa programu}). Buduje on strukturê programu, aby w kolejnym kroku uruchomiæ go pod adresem IP urz¹dzenia i na porcie o numerze \texttt{4449}.
%\newpage
\begin{lstlisting}[language=Python, caption=Podstawowy kod uruchamiany przy w³¹czeniu aplikacji, 
label={lst:Podstawa programu}]
#tutaj zadeklarowane s¹ biblioteki#

app = Flask(__name__)

#tutaj siê mieœci reszta kodu aplikacji#

if __name__ == '__main__':
    app.run('0.0.0.0', 4449)
\end{lstlisting}


\subsection{Utworzenie po³¹czenia z baz¹ danych}
Aby mo¿na by³o skorzystaæ z bazy danych utworzono do niej po³¹czenie (lis.~\ref{lst:Konfiguracja polaczenia bazy danych i aplikacji}).
\begin{lstlisting}[language=Python, caption=Konfiguracja po³¹czenia bazy danych i aplikacji, label={lst:Konfiguracja polaczenia bazy danych i aplikacji}]
app.secret_key = 'klucz'
app.config['MYSQL_HOST'] = 'localhost'
app.config['MYSQL_USER'] = 'root'
app.config['MYSQL_PASSWORD'] = 'admin'
app.config['MYSQL_DB'] = 'daza_danych_ofert'
\end{lstlisting}

\subsection{Implementacja wymaganych funkcji}
\subsubsection{Tworzenie nowego konta}
Na pocz¹tku sprawdzane jest, czy u¿ytkownik nie jest ju¿ zalogowany. Je¿eli jest, to wyœwietla siê  strona domowa z informuj¹cym komunikatem. W przeciwnym przypadku ³aduje siê podstrona rejestracji z szablonem do wype³nienia. Po uzupe³nieniu pól i zatwierdzeniu danych przyciskiem tworzone s¹ nowe wpisy w encji \texttt{U¿ytkownika} oraz \texttt{Personalia} (lis.~\ref{lst:rejestracja}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstronê /rejestracja, label={lst:rejestracja}]
@app.route('/rejestracja', methods=['GET', 'POST'])
def rejestracja():
    if session:
        return render_template('index.html',listaOfert=listaOfert('ANY'), msg ='Jestes juz zalogowany jako ' + str(session['username']))

    if request.method == 'POST':
        uzytkownik = request.form.get('inputUzytkownik')
        email = request.form.get('inputEmail')
        haslo = request.form.get('inputHaslo')

        tworzenieKonta = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        tworzenieKonta.execute('BEGIN; INSERT INTO uzytkownik (login, haslo) VALUES ( % s, % s); INSERT INTO personalia (ID_uzytkownika, `e-mail`) VALUES (last_insert_id(), % s); COMMIT;', (uzytkownik, haslo, email ))
        #mysql.connection.commit
        
        return render_template('index.html',listaOfert=listaOfert('ANY') ,msg ='Rejestracja przebiegla pomyslnie. Teraz mozesz sie zalogowac')

    return render_template('rejestracja.html')
\end{lstlisting}

\subsubsection{Logowanie siê na konto}
Funkcja zaczyna siê od potwierdzenia, czy u¿ytkownik jest zalogowany na konto. Je¿eli jest, to wyœwietla siê  strona domowa z odpowiednim komunikatem. W przeciwnym razie ³aduje siê podstrona umo¿liwiaj¹ca zalogowanie siê. Po naciœniêciu przycisku ``Zaloguj siê`` wykonuje siê kwerenda SQL sprawdzaj¹ca, czy konto o podanym loginie i haœle istnieje w bazie. Jeœli znajduje to tworzy siê nowa sesja. Przechowuje ona dwie wrtoœci login i ID u¿ytkownika. W przeciwnym wypadku ³adowana jest strona domowa z komunikatem o nieudanej próbie logowania (lis.~\ref{lst:logowanie}).   
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstronê /logowanie, label={lst:logowanie}]
@app.route('/logowanie', methods=['GET', 'POST'])
def logowanie():
    if session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Jestes juz zalogowany jako ' + str(session['username']))
    if request.method == 'POST':
        uzytkownik = request.form.get('inputUzytkownik')
        haslo = request.form.get('inputHaslo')
        probaLogowania = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        probaLogowania.execute('SELECT * FROM uzytkownik WHERE login = % s AND haslo = % s', (uzytkownik, haslo ))
        konto = probaLogowania.fetchone()
        if konto:
            session['id'] = konto['ID_uzytkownika']
            session['username'] = konto['login']
            return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Udalo sie zalogowac. Witaj ' + session['username'])
        else:
            return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Nie udalo sie zalogowac. Wpisales zle haslo lub login.')
    return render_template('logowanie.html')
\end{lstlisting}
\subsubsection{Dodanie nowej oferty}
Najpierw funkcja upewnia siê, czy u¿ytkownik jest zalogowany. Je¿eli jest, to ³adowana jest podstrona pozwalaj¹ca dodaæ now¹ ofertê. W innym przypadku aplikacja wraca do strony g³ównej i wyœwietla odpowiedni komunikat. Po wype³nieniu pól i zatwierdzeniu przyciskiem tworzony jest nowy wpis w encji \texttt{Oferta} na podstawie wprowadzonych danych i informacji o sesji (lis.~\ref{lst:dodajOferte}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstrone /dodajOferte, label={lst:dodajOferte}]
def dodawanieOferty():
    if not session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Zaloguj sie lub utworz konto, by dodac oferte')
    if request.method == 'POST':
        nazwaProduktu = request.form.get('inputNameOfProduct')
        opis = request.form.get('inputDescription')
        ilosc = request.form.get('inputAmount')
        cena = request.form.get('inputPrice')
        dodanieOferty = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        dodanieOferty.execute('INSERT INTO oferta (ID_uzytkownika, nazwa_produktu, opis, liczba_sztuk, cena) VALUES ( % s, % s, % s, % s, % s)', (session['id'], nazwaProduktu, opis, ilosc, cena ))
        mysql.connection.commit()
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Pomyslnie dodano produkt')
    return render_template('/dodawanieoferty.html')
\end{lstlisting}
\subsubsection{Wyœwietlanie i usuwanie ofert stworzonych przez u¿ytkownika}
W piwerwszej kolejnoœci funkcja sprawdza czy u¿ytkownika jest zalogowany. Je¿eli jest, to wyœwietla siê podstrona ze wszystkimi ofertami, znalezionymi w bazie danych, które nale¿¹ do u¿ytkownika. W przeciwnym razie ³aduje siê strona domowa z dopasowanym komunikatem. Ka¿da oferta posiada przycisk ``Usuñ``. Za jego pomoc¹ mo¿na zliklidowaæ dan¹ ofertê z bazy danych. Po jego naciœniêciu kwerenda usuwa ofertê z encji \texttt{Oferta}, przechodzi na stronê domow¹ i wyœwietla adekwatn¹ informacjê (lis.~\ref{lst:mojeOferty}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstrone /mojeOferty, label={lst:mojeOferty}]
def mojeoferty():
    if not session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Zaloguj sie, by zobaczyc swoje oferty')    
    
    if request.method == 'POST':
        usunOferte = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        usunOferte.execute('DELETE FROM oferta WHERE ID_oferty = % s', (str(request.form.get('usun'))))
        mysql.connection.commit()
        return render_template('index.html' ,msg= 'Oferta zostala usunieta' ,listaOfert=listaOfert('ANY'))
    return render_template('mojeOferty.html' ,listaOfert=listaOfert(session['id']))
\end{lstlisting}
\subsubsection{Wyœwietlanie i edytowanie personalnych danych u¿ytkownika}
Na pocz¹tku sprawdza czy sesja u¿ytkownika jest aktywa. Je¿eli jest, to ³aduje podstronê z~personalnymi danymi nale¿¹cymi do u¿ytkownika. Ponadto istnieje mo¿liwoœæ ich uaktualnienia. Po wpisaniu nowego imienia, nazwiska, numeru telefonu oraz adres e-mail i zatwierdzenia przyciskiem ``Zapisz`` wykonuje siê kwerenda aktualizuj¹ca wpis w encji \texttt{Personalia}. Po jej pomyœlnym zakoñczeniu wyœwietla siê strona g³ówna (lis.~\ref{lst:mojeDane}).		
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstrone /mojeDane, label={lst:mojeDane}]
@app.route('/mojeDane', methods=['GET', 'POST'])
def mojeDane():
    if not session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Zaloguj sie, by zobaczyc swoje dane')
    if request.method == 'POST':
        imie = request.form.get('inputName')
        nazwisko = request.form.get('inputSurname')
        telefon = request.form.get('inputNumber')
        if telefon == 'None':
            telefon = 0
        email = request.form.get('inputEmail')
        aktualizacjaDanych = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        aktualizacjaDanych.execute('UPDATE personalia SET imie = % s, nazwisko = % s, nr_telefonu = % s, `e-mail` = % s WHERE ID_uzytkownika = % s', (imie, nazwisko, telefon, email, str(session['id']) ))
        mysql.connection.commit()
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Zmiany zapisano')
    mojeDane = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
    mojeDane.execute('SELECT imie, nazwisko, nr_telefonu, `e-mail` FROM personalia WHERE ID_uzytkownika = % s', (str(session['id'])))
    mysql.connection.commit()
    mojeDane.close()
    
    return render_template('mojeDane.html', mojeDane=mojeDane)
\end{lstlisting}
\subsubsection{Wylogowanie siê z konta}
W pierwszej kolejnoœci funkcja sprawdza, czy nie ma aktywnej sesji. Je¿eli nie ma to u¿ytkownik wraca na stronê g³ówna z odpowiednik komunikatem. W przeciwnym wypadku usuwa istniej¹c¹ sesjê i ³aduje stronê g³ówn¹ z komunikatem o pomyœlnym wylogowaniu siê (lis.~\ref{lst:wyloguj}).
% TO DO: proszê zwróciæ uwagê na literówki: przegieblo OK
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstrone /wyloguj, label={lst:wyloguj}]
@app.route('/wyloguj')
def wyloguj():
    if not session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Nie jestes zalogowany na zadne konto')
    session.pop('id', None)
    session.pop('username', None)
    return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Wylogowanie przebieglo pomyslnie')
\end{lstlisting}
\subsubsection{Wyœwietlanie wszystkich ofert}
Funkcja ka¿dorazowo wykonuje siê po uruchomieniu programu. Odpowiada ona za ³adowanie siê strony g³ównej oraz wyœwietlanie wszystkich wpisów z encji \texttt{Oferta}, je¿eli istnieje aktywna sesja u¿ytkownika (lis.~\ref{lst:home}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na strone g³ówn¹ lub po za³adowaniu podstawy programu, label={lst:home}]
def listaOfert(IDuzytkownika):
    listaOfert = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
    if IDuzytkownika != 'ANY':
        listaOfert.execute('SELECT uzytkownik.login, oferta.nazwa_produktu, oferta.opis, oferta.liczba_sztuk, oferta.cena, oferta.ID_oferty FROM oferta INNER JOIN uzytkownik ON oferta.ID_uzytkownika=uzytkownik.ID_uzytkownika WHERE oferta.ID_uzytkownika = % s', (str(IDuzytkownika)))
    else:
        listaOfert.execute('SELECT uzytkownik.login, oferta.nazwa_produktu, oferta.opis, oferta.liczba_sztuk, oferta.cena FROM oferta INNER JOIN uzytkownik ON oferta.ID_uzytkownika=uzytkownik.ID_uzytkownika')
    mysql.connection.commit()
    listaOfert.close()
    
    return listaOfert
@app.route('/')
@app.route('/home')
def index():
    if session:
        return render_template('index.html', listaOfert=listaOfert('ANY'))
    return render_template('index.html', msg="Zaloguj sie w celu przegladania ofert")
\end{lstlisting}