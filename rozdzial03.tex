\chapter{Budowa aplikacji}
Jednym z celów pracy jest stworzenie autorskiej aplikacji. Rozdzia³ drugi poœwiêcony jest jej projektowi. Pos³u¿y ona za obiekt, na którym zostan¹ wykonane testy bezpieczeñstwa. 
\section{Opis aplikacji}
Stworzona aplikacja nale¿y do typu aplikacji internetowej (webowej). G³ównym jej zadaniem jest mo¿liwoœæ wystawiania og³oszeñ z produktem, który chcemy oddaæ lub sprzedaæ. Drug¹ równie wa¿n¹ mo¿liwoœci¹ jest przegl¹dnie og³oszeñ pozosta³ych u¿ytkowników na g³ównej stronie.
Osoba po stworzeniu konta i zalogowaniu siê na nie posiada kilka podstawowych funkcjonalnoœci, z których mo¿e skorzystaæ po pozytywnym przejœciu próby zalogowania siê. Do ich grupy nale¿y: wyœwietlenie informacji o w³aœcicielu konta, dodawanie nowego og³oszenia, wyœwietlanie listy wszystkich wystawionych og³oszeñ oraz wyœwietlanie i usuwanie dodanych og³oszeñ przez ich w³aœciciela.

\section{Wymagania aplikacji}
Wymagania aplikacji dziel¹ siê na funkcjonalne i niefunkcjonalne. Pierwsze z nich okreœlaj¹ mo¿liwoœci zapewniane u¿ytkownikowi, je¿eli aplikacja prawid³owo dzia³a. Drugie przedstawiaj¹ mo¿liwoœci wynikaj¹ce z jej budowy. Nastêpne podrozdzia³y wymieniaj¹ funkcjonalnoœci zawarte w projekcie.  
\subsection{Wymagania funkcjonalne}
\begin{itemize}[leftmargin=1cm]
	\item Tworzenie nowego konta
	\item Logowanie siê na konto
	\item Dodanie nowego og³oszenia
	\item Wyœwietlenie og³oszeñ stworzonych przez u¿ytkownika
	\item Usuwanie og³oszenia stworzonych przez u¿ytkownika
	\item Wyœwietlanie personalnych informacji
	\item Wylogowanie siê z konta
\end{itemize}
\subsection{Wymagania niefunkcjonalne}
% TODO: Proszê doczytaæ, czym s¹ wymagania niefunkcjonalne!!!!
%%      To, co Pan napisa³, jest niepoprawne !!!!!!
\begin{itemize}[leftmargin=1cm]
	\item Wyœwietlenie wszystkich og³oszeñ
\end{itemize}

\section{Projekt bazy danych}
Podczas projektowania schematu bazy danych stworzono kolejno trzy modele: uproszczony model konceptualny, rozszerzony model konceptualny (inaczej model logiczny) oraz model fizyczny. Opieraj¹c siê na nich stworzono i wygenerowano bazê danych u¿yt¹ podczas implementacji aplikacji.

Modelowanie schematów baz danych mo¿e odbywaæ siê z wykorzystaniem ró¿nych notacji. W niniejszej pracy pos³u¿ono siê elementami notacji ,,kurzej ³apki'' (ang.~\emph{Crow's Foot Notation}). Elementy tej notacji pojawiaj¹ siê w ró¿nych standardach modelowania, np. w Notacji In¿ynierii Informacyjnej/Relacyjnej (ang.~\emph{Information Engineering/Relational Notation}, IE/Relational Notation) czy te¿ w Notacji Bakera (ang.~\emph{Barker's Notation}).
% TO DO: tutaj móg³by Pan wstawiæ jak¹œ referencjê do Ÿród³a/ksi¹¿ki/artyku³u, w którym opisano te notacje

\subsection{Uproszczony model konceptualny}
Pierwszy z przedstawionych modeli pokazuje encje oraz wystêpuj¹ce pomiêdzy nimi relacje (rys.~\ref{fig:Rys03/UproszczonyModelKonceptualny}). Schemat bazy danych opiera siê na tabeli \textit{U¿ytkownik}. Jako jedyna posiada ona relacje z pozosta³ymi encjami. Miêdzy tabel¹ \textit{U¿ytkownik} oraz \textit{Personalia} istnieje relacja identyfikuj¹ca. Mówi ona o tym, ¿e tabela \textit{Personalia} dziedziczy klucz g³ówny od tabeli U¿ytkownik. W przypadku relacji pomiêdzy encj¹ \textit{U¿ytkownik} i \textit{Oferta} istnieje relacja nieidentyfikuj¹ca, poniewa¿ obie tabele posiadaj¹ dwa ró¿ne klucze g³ówne.
\begin{figure}[htb]
\centering
\includegraphics[scale=1.4]{Rys03/UproszczonyModelKonceptualny}
\caption{Uproszczony model konceptualny}
\label{fig:Rys03/UproszczonyModelKonceptualny}
\end{figure}

\subsection{Rozszerzony model konceptualny}
Korzystaj¹c z uproszczonego modelu konceptualnego stworzono jego rozszerzon¹ wersjê jak na rysunku~\ref{fig:Rys03/ModelLogiczny}. Tabele w tym modelu posiadaj¹ dwie kolumny: w lewej wpisywane s¹ oznaczenia kluczy (jeœli dany atrybut jest kluczem), w prawej zaœ nazwy atrybutów. Ka¿da encja posiada klucz g³ówny (ang.~\emph{primary key}, PK). Encje \texttt{U¿ytkownik} i \texttt{Oferta} posiadaj¹ kolejno klucze g³ówne o nazwie \texttt{ID\_u¿ytkownika} oraz \texyyy{ID\_oferty}. Encja \texttt{Pesonalia} dziedziczy klucz g³ówny od encji \texttt{U¿ytkownik}, który jest zarazem kluczem obcym (ang.~\emph{foreign key}, FK). Ponadto encja \texttt{Oferta} dziedziczy g³ówny klucz encji \textit{U¿ytkownik} jako klucz obcy. Pod kluczami wypisano wszystkie indeksy jakie nale¿¹ do poszczególnych encji.
\begin{figure}[ht]
\centering
\includegraphics[scale=1.4]{Rys03/ModelLogiczny}
\caption{Rozszerzony model konceptualny}
\label{fig:Rys03/ModelLogiczny}
\end{figure}

%\newpage
%\vfill
\subsection{Model fizyczny}
Opieraj¹c siê na rozszerzonym modelu konceptualnym sporz¹dzono model fizyczny jak na rysunku~\ref{fig:Rys03/ModelFizyczny}). Podczas nazywania elementów tego modelu zrezygnowano z u¿ywania polskich znaków diakrytycznych. Encje maj¹ po dwie kolumny: lewa zawiera nazwy indeksów, oznaczenia kluczy g³ównych i obcych, natomiast w prawej kolumnie okreœlono cechy poszczególnych indeksów. Znaczenia u¿ytych skrótów wyjaœniono poni¿ej.
\begin{itemize}[leftmargin=1cm]
\item ograniczenia:
\begin{itemize}
	\item \texttt{NOT NULL} -- indeks nigdy nie mo¿e przyj¹æ, przechowywaæ wartoœci \texttt{NULL},
	\item \texttt{UNIQUE} -- indeks musi posiadaæ inn¹ wartoœæ dla ka¿dego wpisu w encji,
\end{itemize}
\item typy danych:
	\begin{itemize}
		\item \texttt{int} -- wartoœæ mo¿e byæ liczb¹ ca³kowit¹ z przedzia³u <$2^{-31}-1$;    $2^{31}-1$> 
		\item \texttt{double} -- wartoœæ mo¿e byæ liczb¹ dziesiêtn¹
		\item \texttt{varchar[x]} -- wartoœæ mo¿e byæ ci¹giem znaków o maksymalnej d³ugoœci \texttt{x}. W przypadku napisania krótszego ci¹gu znaków nie wype³nia brakuj¹cych znaków spacjami,
		\item \texttt{text} -- wartoœæ mo¿e byæ d³ugim ci¹giem znaków, zawieraj¹cym do $2^{31}-1$ znaków.
	\end{itemize} 
\end{itemize}

\begin{figure}[htb]
\centering
\includegraphics[scale=1.4]{Rys03/ModelFizyczny}
\caption{Model fizyczny}
\label{fig:Rys03/ModelFizyczny}
\end{figure}

%\newpage
\subsection{Generowanie bazy danych}
Stosuj¹c ostatni z przedstawionych modeli, czyli model fizyczny, i narzêdzie MySQL Workbench wygenerowano bazê danych. Najpierw skorzystano z edytora diagramu EER (ang.~\emph{Enhanced entity-relationship}), aby stworzyæ za jego pomoc¹ odpowiednik przedstawionego modelu fizycznego (patrz na rysunek~\ref{fig:Rys03/EERDiagram.png}). W kolejnym kroku wybrano opcjê generowania bazy na podstawie stworzonego diagramu. Proces ten zakoñczy³ siê sukcesem (patrz na rysunek~\ref{fig:Rys03/Success.png}).
\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{Rys03/EERDiagram.png}
\caption{Diagram EER utworzony w MySQL Workbench}
\label{fig:Rys03/EERDiagram.png}
\end{figure}

%\newpage
\begin{figure}[h!]
\centering
\includegraphics[scale=0.2]{Rys03/Success.png}
\caption{Pozytywnie zakoñczone tworzenie bazy w MySQL Workbench}
\label{fig:Rys03/Success.png}
\end{figure}

\section{Projekt aplikacji}
\subsection{U¿yte narzêdzia i biblioteki}
Aplikacjê zaprojektowano przy u¿yciu narzêdzia Visual Studio Community 2022 oraz napisano za pomoc¹ jêzyka programowania Python. Poni¿ej przedstawino biblioteki, klasy, funkcje itp. u¿ywane przez program (patrz na listing~\ref{lst:Python biblioteki}). Do budowy aplikacji webowej zdecydowano siê u¿yæ frameworka Flask. Wykorzystano tak¿e przy pisaniu kolejncyh czêœci kodu. Ponadto u¿yto biblioteki flask\_mysqldb., która zapewnia po³¹czenie miêdzy Flask, a MySQL. Klasa MySQLdb.cursors pozwala wykonywaæ i zapisywaæ wynik zapytania SQL w zmiennej typu s³ownik.
\begin{lstlisting}[language=Python, caption=Wykorzystane biblioteki w projekcie aplikacji, label={lst:Python biblioteki}]
from flask import Flask, render_template, request, session
from flask_mysqldb import MySQL
import MySQLdb.cursors
\end{lstlisting}

\subsection{Podstawa programu}
Ka¿dorazowo przy uruchamianiu aplikacji wykonywany jest poni¿szy kod (patrz na listing~\ref{lst:Podstawa programu}). Buduje on strukturê programu, aby w kolejnym kroku uruchomiæ go pod adresem localhost i na porcie o numerze 4449.
%\newpage
\begin{lstlisting}[language=Python, caption=Podstawowy kod uruchamiany przy w³¹czeniu aplikacji, 
label={lst:Podstawa programu}]
#tutaj zadeklarowane s¹ biblioteki#

app = Flask(__name__)

#tutaj siê mieœci reszta kodu aplikacji#

if __name__ == '__main__':
    app.run('localhost', 4449)
\end{lstlisting}


\subsection{Utworzenie po³¹czenia z baz¹ danych}
Chc¹ wykorzystaæ stworzn¹ bazê danych uworzono z ni¹ po³¹czenie (patrz na listing~\ref{lst:Konfiguracja polaczenia bazy danych i aplikacji}).
\begin{lstlisting}[language=Python, caption=Konfiguracja po³¹czenia bazy danych i aplikacji, label={lst:Konfiguracja polaczenia bazy danych i aplikacji}]
app.secret_key = 'klucz'
app.config['MYSQL_HOST'] = 'localhost'
app.config['MYSQL_USER'] = 'root'
app.config['MYSQL_PASSWORD'] = 'admin'
app.config['MYSQL_DB'] = 'daza_danych_ofert'
\end{lstlisting}

\subsection{Implementacja funkcjonalnoœci}
\subsubsection{Tworzenie nowego konta}
Na pocz¹tku sprawdzane jest, czy u¿ytkownik nie jest ju¿ zalogowany. Je¿eli jest, to wyœwietla siê  strona domowa z informuj¹cym komunikatem. W przeciwnym przypadku ³aduje siê podstrona rejestracji z szablonem do wype³anienia. Po uzupe³nieniu pól i zatweirdzeniu danych przyciskiem tworzone s¹ nowe wpisy w encji \textit{U¿ytkownika} oraz \textit{Personalia} (patrz na listing~\ref{lst:rejestracja}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstronê /rejestracja, label={lst:rejestracja}]
@app.route('/rejestracja', methods=['GET', 'POST'])
def rejestracja():
    if session:
        return render_template('index.html',listaOfert=listaOfert('ANY'), msg ='Jestes juz zalogowany jako ' + str(session['username']))

    if request.method == 'POST':
        uzytkownik = request.form.get('inputUzytkownik')
        email = request.form.get('inputEmail')
        haslo = request.form.get('inputHaslo')

        tworzenieKonta = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        tworzenieKonta.execute('BEGIN; INSERT INTO uzytkownik (login, haslo) VALUES ( % s, % s); INSERT INTO personalia (ID_uzytkownika, `e-mail`) VALUES (last_insert_id(), % s); COMMIT;', (uzytkownik, haslo, email ))
        #mysql.connection.commit
        
        return render_template('index.html',listaOfert=listaOfert('ANY') ,msg ='Rejestracja przebiegla pomyslnie. Teraz mozesz sie zalogowac')

    return render_template('rejestracja.html')
\end{lstlisting}

\subsubsection{Logowanie siê na konto}
Funkcja zaczyna siê od potwierdzenia, czy u¿ytkownik jest zalogowany na konto. Je¿eli jest, to wyœwietla siê  strona domowa z odpowiednim komunikatem. W przeciwnym razie ³aduje siê podstrona umo¿liwiaj¹ca zalogowanie siê. Po naciœniêciu przycisku ``Zaloguj siê`` wykonuje siê kwerenda SQL sprawdzaj¹ca, czy konto o podanym loginie i haœle istnieje w bazie. Jeœli znajduje to tworzy siê nowa sesja. Przechowuje ona dwie wrtoœci login i ID u¿ytkownika. W przeciwnym wypadku ³adowana jest strona domowa z komunikatem o nieudanej próbie logowania (patrz na listing~\ref{lst:logowanie}).   
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstronê /logowanie, label={lst:logowanie}]
@app.route('/logowanie', methods=['GET', 'POST'])
def logowanie():
    if session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Jestes juz zalogowany jako ' + str(session['username']))

    if request.method == 'POST':
        uzytkownik = request.form.get('inputUzytkownik')
        haslo = request.form.get('inputHaslo')

        probaLogowania = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        probaLogowania.execute('SELECT * FROM uzytkownik WHERE login = % s AND haslo = % s', (uzytkownik, haslo ))

        konto = probaLogowania.fetchone()
        if konto:
            session['id'] = konto['ID_uzytkownika']
            session['username'] = konto['login']
            return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Udalo sie zalogowac. Witaj ' + session['username'])
        else:
            return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Nie udalo sie zalogowac. Wpisales zle haslo lub login.')

    return render_template('logowanie.html')
\end{lstlisting}

\subsubsection{Dodanie nowej oferty}
Najpierw funkcja upewnia siê, czy u¿ytkownik jest zalogowany. Je¿eli jest, to ³adowana jest podstrona pozwalaj¹ca dodaæ now¹ ofertê. W innym przypadku aplikacja wraca do strony g³ównej i wyœwietla odpowiedni komunikat. Po wype³nieniu pól i zatwierdzeniu przyciskiem tworzony jest nowy wpis w encji \textit{Oferta} na podstawie wprowadzonych danych i informacji o sesji (patrz na listing~\ref{lst:dodajOferte}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstrone /dodajOferte, label={lst:dodajOferte}]
def dodawanieOferty():
    if not session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Zaloguj sie lub utworz konto, by dodac oferte')

    if request.method == 'POST':
        nazwaProduktu = request.form.get('inputNameOfProduct')
        opis = request.form.get('inputDescription')
        ilosc = request.form.get('inputAmount')
        cena = request.form.get('inputPrice')

        dodanieOferty = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        dodanieOferty.execute('INSERT INTO oferta (ID_uzytkownika, nazwa_produktu, opis, liczba_sztuk, cena) VALUES ( % s, % s, % s, % s, % s)', (session['id'], nazwaProduktu, opis, ilosc, cena ))

        mysql.connection.commit()

        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Pomyslnie dodano produkt')

    return render_template('/dodawanieoferty.html')
\end{lstlisting}

\subsubsection{Wyœwietlanie i usuwanie ofert stworzonych przez u¿ytkownika}
W piwerwszej kolejnoœci funkcja sprawdza czy u¿ytkownika jest zalogowany. Je¿eli jest, to wyœwietla siê podstrona ze wszystkimi ofertami, znalezionymi w bazie danych, które nale¿¹ do u¿ytkownika. W przeciwnym razie ³aduje siê strona domowa z dopasowanym komunikatem. Ka¿da oferta posiada przycisk ``Usuñ``. Za jego pomoc¹ mo¿na zliklidowaæ dan¹ ofertê z bazy danych. Po jego naciœniêciu kwerenda usuwa ofertê z encji \textit{Oferta}, przechodzi na stronê domow¹ i wyœwietla adekwatn¹ informacjê (patrz na listing~\ref{lst:mojeOferty}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstrone /mojeOferty, label={lst:mojeOferty}]
def mojeoferty():
    if not session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Zaloguj sie, by zobaczyc swoje oferty')    
    
    if request.method == 'POST':
        usunOferte = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        usunOferte.execute('DELETE FROM oferta WHERE ID_oferty = % s', (str(request.form.get('usun'))))

        mysql.connection.commit()
        return render_template('index.html' ,msg= 'Oferta zostala usunieta' ,listaOfert=listaOfert('ANY'))

    return render_template('mojeOferty.html' ,listaOfert=listaOfert(session['id']))
\end{lstlisting}

\subsubsection{Wyœwietlanie i edytowanie personalnych danych u¿ytkownika}
Na pocz¹tku sprawdza czy sesja u¿ytkownika jest aktywa. Je¿eli jest, to ³aduje podstronê z personalnymi danymi nale¿¹cymi do u¿ytkownika. Ponadto istnieje mo¿liwoœæ ich uaktualnienia. Po wpisaniu nowego imienia, nazwiska, numeru telefonu oraz adres e-mail i zatwierdzenia przyciskiem ``Zapisz`` wykonuje siê kwerenda aktualizuj¹ca wpis w encji \textit{Personalia}. Po jej pomyœlnym zakoñczeniu wyœwietla siê strona g³ówna (patrz na listing~\ref{lst:mojeDane}).		
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstrone /mojeDane, label={lst:mojeDane}]
@app.route('/mojeDane', methods=['GET', 'POST'])
def mojeDane():
    if not session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Zaloguj sie, by zobaczyc swoje dane')

    if request.method == 'POST':
        imie = request.form.get('inputName')
        nazwisko = request.form.get('inputSurname')
        telefon = request.form.get('inputNumber')
        if telefon == 'None':
            telefon = 0
        email = request.form.get('inputEmail')

        aktualizacjaDanych = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
        aktualizacjaDanych.execute('UPDATE personalia SET imie = % s, nazwisko = % s, nr_telefonu = % s, `e-mail` = % s WHERE ID_uzytkownika = % s', (imie, nazwisko, telefon, email, str(session['id']) ))

        mysql.connection.commit()

        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Zmiany zapisano')


    mojeDane = mysql.connection.cursor(MySQLdb.cursors.DictCursor)

    mojeDane.execute('SELECT imie, nazwisko, nr_telefonu, `e-mail` FROM personalia WHERE ID_uzytkownika = % s', (str(session['id'])))
    mysql.connection.commit()
    mojeDane.close()
    

    return render_template('mojeDane.html', mojeDane=mojeDane)
\end{lstlisting}

\subsubsection{Wylogowanie siê z konta}
W pierwszej kolejnoœci funkcja sprawdza, czy nie ma aktywnej sesji. Je¿eli nie ma to u¿ytkownik wraca na stronê g³ówna z odpowiednik komunikatem. W przeciwnym wypadku usuwa istniej¹c¹ sesjê i ³aduje stronê g³ówn¹ z komunikatem o pomyœlnym wylogowaniu siê (patrz na listing~\ref{lst:wyloguj}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na podstrone /wyloguj, label={lst:wyloguj}]
@app.route('/wyloguj')
def wyloguj():
    if not session:
        return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Nie jestes zalogowany na zadne konto')

    session.pop('id', None)
    session.pop('username', None)

    return render_template('index.html' ,listaOfert=listaOfert('ANY'), msg ='Wylogowanie przegieblo pomyslnie')
\end{lstlisting}

\subsubsection{Wyœwietlanie wszystkich ofert}
Funkcja ka¿dorazowo wykonuje siê po uruchomieniu programu. Odpowiada ona za ³adowanie siê strony g³ównej oraz wyœwietlanie wszystkich wpisów z encji \textit{Oferta}, je¿eli istnieje aktywna sesja u¿ytkownika (patrz na listing~\ref{lst:home}).
\begin{lstlisting}[language=Python, caption=Funkcja wykonywana po wejœciu na strone g³ówn¹ lub po za³adowaniu podstawy programu, label={lst:home}]
def listaOfert(IDuzytkownika):
    listaOfert = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
    if IDuzytkownika != 'ANY':
        listaOfert.execute('SELECT uzytkownik.login, oferta.nazwa_produktu, oferta.opis, oferta.liczba_sztuk, oferta.cena, oferta.ID_oferty FROM oferta INNER JOIN uzytkownik ON oferta.ID_uzytkownika=uzytkownik.ID_uzytkownika WHERE oferta.ID_uzytkownika = % s', (str(IDuzytkownika)))
    else:
        listaOfert.execute('SELECT uzytkownik.login, oferta.nazwa_produktu, oferta.opis, oferta.liczba_sztuk, oferta.cena FROM oferta INNER JOIN uzytkownik ON oferta.ID_uzytkownika=uzytkownik.ID_uzytkownika')

    mysql.connection.commit()
    listaOfert.close()
    
    return listaOfert

@app.route('/')
@app.route('/home')
def index():
    if session:
        return render_template('index.html', listaOfert=listaOfert('ANY'))

    return render_template('index.html', msg="Zaloguj sie w celu przegladania ofert")
\end{lstlisting}
