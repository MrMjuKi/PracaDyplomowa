\chapter{Implementacja zmian i ponowny audyt}
W rozdziale omówiono zmiany wprowadzone do aplikacji. Koniecznoœæ ich wprowadzenia wynik³a z analizy podsumowania przeprowadzonego wczeœniej audytu bezpieczeñstwa.
Po wprowadzeniu zmian przeprowadzono finalny audyt. Jego wyniki omówiono na koñcu rozdzia³u.

\section{Limit prób logowañ}
W celu ograniczenia du¿ej liczby ¿¹dañ pojawiaj¹cych siê w krótkim zakresie czasu na stronie logowania zdecydowano siê zadeklarowaæ limity. U¿yto do tego funkcji z biblioteki \texttt{flask\_limiter} i \texttt{flask\_limiter.util} jak na listingu~\ref{lst:limitLogowan}. 
Wymaga³o to globalnej deklaracji aplikacji oraz adresu IP, których dotyczy limit (lis.~\ref{lst:globalLimiter}). 
Dla podstrony logowanie skonfigurowano maksymalnie piêæ logowañ na godzinê (lis.~\ref{lst:logowanieLimit}). 
\begin{lstlisting}[language=Python, caption=Biblioteki u¿yte przy konfiguracji limitów, label={lst:limitLogowan}, basicstyle=\footnotesize\ttfamily]
flask_limiter import Limiter
from flask_limiter.util import get_remote_address
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=Globalna konfiguracja limitera, label={lst:globalLimiter}, basicstyle=\footnotesize\ttfamily]
limiter = Limiter(app, key_func=get_remote_address)
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=Skonfigurowanie limitu logowañ, label={lst:logowanieLimit}, basicstyle=\footnotesize\ttfamily]
@limiter.limit("5/hour", error_message='Osiagnieto limit pieciu prob zalogowania sie. Sprobuj za godzine')
# tutaj funkcja podstrony logowania siê 
\end{lstlisting}

Dodatkowo dla b³êdu 429 ustawiono informacjê ,,Przekroczyles limit ¿¹dañ'' (lis.~\ref{lst:429error}).
\begin{lstlisting}[language=Python, caption=Skonfigurowanie informacji przy b³êdzie 429, label={lst:429error}, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
@app.errorhandler(429)
def ratelimit_handler():
  return "Przekroczyles limit zadan"
\end{lstlisting}

\section{Walidacja pól na podstronie tworzenia konta}
Aby zapobiec pojawianiu siê b³êdów znalezionych na podstronie rejestracji utworzono walidacjê dla podawanych na niej danych (lis.~\ref{lst:bibliotekiWalidacja}). W celu sprawdzenia poprawnej formy e-mailu zaimportowano funkcjê (lis.~\ref{lst:walidacjeRejestracja}), która w polu u¿ytkownik testuje, czy pole jest puste i posiada tylko litery i cyfry. Dla pola e-mail sprawdzana jest poprawnoœæ budowy wpisanego e-mailu oraz to czy pole jest wype³nione. W ostatnim polu has³o jest  weryfikowane tylko wystêpowanie zawartoœci, lub jej brak. W przypadku niespe³nienia którejœ z walidacji, pojawia siê stosowny komunikat.

\begin{lstlisting}[language=Python, caption=Biblioteka u¿yta przy walidacji danych, label={lst:bibliotekiWalidacja}, basicstyle=\footnotesize\ttfamily]
import re
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Skonfigurowanie walidaji pola login, e-mail i has³o}, label={lst:walidacjeRejestracja}, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
if not uzytkownik.isalnum():
	return render_template('index.html', msg ='Zla nazwa uzytkownika')

if not re.match('^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$', email):
	return render_template('index.html', msg ='Zly e-mail')
        
if not haslo:
	return render_template('index.html', msg ='Uzupelnij pole haslo')
\end{lstlisting}

\section{Weryfikacja nazwy u¿ytkownika i adresu e-mail}
Równie¿ w tej implementacji wykorzystano funkcjê widoczn¹ na listingu~\ref{lst:bibliotekiWalidacja}. Wed³ug modelu fizycznego bazy danych (rys.~\ref{fig:Rys02/ModelFizyczny}) wartoœci e-mil oraz login powinny byæ unikalne dla ka¿dego u¿ytkownika. Przy rejestracji dopisano kod weryfikuj¹cy, czy wpisany e-mail lub login nie  zosta³ ju¿ u¿yty w bazie przez inne konto. Je¿eli tak, to wyœwietla odpowiednia informacjê (lis.~\ref{lst:weryfikacja}).

\begin{lstlisting}[language=Python, caption={Weryfikacja loginu i e-mailu podczas rejestracji}, label={lst:weryfikacja}, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
szukanieEmailu = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
szukanieEmailu.execute('SELECT `e-mail` FROM personalia WHERE `e-mail` =  % s', [email])
mysql.connection.commit
if szukanieEmailu.fetchone():
	return render_template('index.html', msg ='Konto o podanym e-mailu istnieje')

szukanieLoginu = mysql.connection.cursor(MySQLdb.cursors.DictCursor)
szukanieLoginu.execute('SELECT * FROM uzytkownik WHERE login =  % s', [uzytkownik])
mysql.connection.commit
if szukanieLoginu.fetchone():
	return render_template('index.html', msg ='Konto o podanym loginie istnieje')
\end{lstlisting}

\section{Polityka jakoœci has³a i cieniowanie has³a}
Do zaprogramowania obu zmian wykorzystano biblioteki widoczne na listingu~\ref{lst:bibliotekiWalidacja} i listingu~\ref{lst:bibliotekiCieniowanie}. W celu zwiêkszenia minimalnej jakoœci has³a ustawiano wymagania jakie powinno ono spe³niaæ. Nale¿¹ do nich: znak specjalny, ma³a litera, du¿a litera, cyfra i posiadanie ³¹cznie oœmiu lub wiêcej znaków (lis.~\ref{lst:jakoscICieniowanieHasla}). Ponadto dla zwiêkszenia bezpieczeñstwa hase³ s¹ one przechowywane zacieniowane w bazie danych. W sytuacji logowania wpisane has³o jest cieniowane i~porównywane z hashem zapisanym w bazie danych.

\begin{lstlisting}[language=Python, caption={Biblioteka u¿yta do konfiguracji cieniowania has³a}, label={lst:bibliotekiCieniowanie}, basicstyle=\footnotesize\ttfamily]
from hashlib import blake2b
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Sprawdzanie jakoœci i cieniowanie has³a}, label={lst:jakoscICieniowanieHasla}, showstringspaces=false, basicstyle=\footnotesize\ttfamily]
if not re.search('[!@#$%^&*()\-_=+[{\]}\\|;:/?.>,<]', haslo) or not re.search('[a-z]', haslo) or  not re.search('[A-Z]', haslo) or not re.search('[0-9]', haslo) or len(haslo)<8:
	return render_template('index.html', msg ='Zbyt slabe haslo')

hashHaslo = blake2b(('b'+haslo).encode('utf-8')).hexdigest()
\end{lstlisting}


\section{Ponowne przeprowadzenie audytu}
\subsection{Opis audytu}
Po wprowadzeniu zmian ponownie przeprowadzono audyt bezpieczeñstwa. Œrodowisko testowe pozosta³o takie samo jak na rysunku~\ref{fig:Rys04/srodowisko}. Identyczny by³ te¿ rodzaj przeprowadzonego auty oraz wykonane kroki. 

Wyszukano paramentów GET komend¹ \texttt{sqlmap -u 192.168.1.46:4449/}. Wynik okaza³ siê taki sam jak na rysunku~\ref{fig:Rys04/SQLMap1.png}. Nastêpnie uruchomiono polecenie \texttt{sqlmap -u~192.168.1.46:4449/ -crawl=2}. Rezultat pozosta³ jak na pokazanym wczeœniej rysunku~\ref{fig:Rys04/SQLMap2.png}. Nastêpnie u¿yto komendy \texttt{sqlmap -wizard} w konfiguracji jak na rysunku~\ref{fig:Rys04/SQLMap4.png}. Tym razem komunikat pojawiaj¹cy siê w konsoli aplikacji zmieni³ siê. Informuje on o przekroczonej iloœci prób logowañ na godzinê (rys.~\ref{fig:Rys06/Error.png}).
\begin{figure}[htb]
\centering
\includegraphics[scale=0.55]{Rys06/Error.png}
\caption{Konsola aplikacji}
\label{fig:Rys06/Error.png}
\end{figure}

Skorzystano te¿ polecenia \texttt{sqlmap -wizard}, tym razem skonfigurowanego jak na rysunku~\ref{fig:Rys04/SQLMap3.png}. Skan zakoñczy³ siê bez zawieszenia aplikacji. Jednak aplikacja przyjmowa³a bardzo du¿o ¿¹dañ POST w ma³ym przedziale czasu (rys.~\ref{fig:Rys06/Error2.png}). 
\begin{figure}[htb]
\centering
\includegraphics[scale=0.55]{Rys06/Error2.png}
\caption{Konsola aplikacji}
\label{fig:Rys06/Error2.png}
\end{figure}

Nastêpnie u¿yto narzêdzia Metasploit i za³adowano plugin WMAP. Skonfigurowano go opieraj¹c siê na rysunku~\ref{Rys04/Metasploit1.png}. Jego wynik oraz przebieg nie zmieni³ siê, co widaæ przy porównaniu z~wczeœniej pokazanym wycinkiem z konsoli aplikacji (rys.~\ref{Rys04/console2.png})

Na koñcu wykorzystano ponownie exploit \texttt{scanner/mysql/mysql\_login}. Ustawiono go zgodnie z rysunkiem~\ref{Rys04/Metasploit2.png} i, jak wczeœniej, nie uda³o siê go uruchomiæ (rys~\ref{Rys04/Metasploit3.png}).

\subsection{Ocena zaimplementowanych zmian}
Przeprowadzony ponownie audyt wykaza³, i¿ zaimplementowane zmiany w aplikacji zmniejszy³y jej podatnoœæ na ataki. Nie znaleziono ¿adnych parametrów POST i GET, które mo¿na wykorzystaæ do udanego w³amania. Wprowadzono limity prób logowania siê dla u¿ytkowników, aby ochroniæ funkcjê przed skanami oraz atakuj¹cymi, którzy rêcznie chc¹ siê w³amaæ na konto. 

Ponadto wprowadzona polityka jakoœci oraz cieniowania has³a zwiêksza jego bezpieczeñstwo przy przesy³aniu miêdzy klientem, a serwerem aplikacji webowej. Nie wprowadzono jednak zaproponowanego protoko³u HTTPS, który szyfrowa³by po³¹czenie. Rozwi¹zano natomiast wa¿ny problem z wy³¹czaj¹c¹ siê aplikacj¹, przy tworzeniu konta z loginem lub adresem e-mail, które s¹ ju¿ przypisane do innego istniej¹cego konta. 

Podczas audyty zidentyfikowano problem obs³ugi bardzo du¿ej iloœci ¿¹dañ w ma³ym zakresie czasu. Tak jak w przypadku logowania siê mo¿e w³yn¹æ na negatywnie na wydajnoœæ aplikacji.
